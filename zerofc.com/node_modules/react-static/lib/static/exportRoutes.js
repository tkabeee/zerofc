"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread"));

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _os = _interopRequireDefault(require("os"));

var _child_process = require("child_process");

var _chalk = _interopRequireDefault(require("chalk"));

var _utils = require("../utils");

var _fetchSiteData = _interopRequireDefault(require("./fetchSiteData"));

var _fetchRoutes = _interopRequireDefault(require("./fetchRoutes"));

var _plugins = _interopRequireDefault(require("./plugins"));

var cores = Math.max(_os.default.cpus().length, 1);

var _default =
/*#__PURE__*/
function () {
  var _exportRoutes = (0, _asyncToGenerator2.default)(
  /*#__PURE__*/
  _regenerator.default.mark(function _callee(state) {
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return (0, _fetchSiteData.default)(state);

          case 2:
            state = _context.sent;
            _context.next = 5;
            return (0, _fetchRoutes.default)(state);

          case 5:
            state = _context.sent;
            _context.next = 8;
            return buildHTML(state);

          case 8:
            state = _context.sent;
            _context.next = 11;
            return _plugins.default.afterExport(state);

          case 11:
            state = _context.sent;
            return _context.abrupt("return", state);

          case 13:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  function exportRoutes(_x) {
    return _exportRoutes.apply(this, arguments);
  }

  return exportRoutes;
}();

exports.default = _default;

function buildHTML(_x2) {
  return _buildHTML.apply(this, arguments);
}

function _buildHTML() {
  _buildHTML = (0, _asyncToGenerator2.default)(
  /*#__PURE__*/
  _regenerator.default.mark(function _callee2(state) {
    var routes, _state$config, paths, maxThreads, threads, htmlProgress, exporters, i, exporterRoutes;

    return _regenerator.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            routes = state.routes, _state$config = state.config, paths = _state$config.paths, maxThreads = _state$config.maxThreads;
            (0, _utils.time)(_chalk.default.green("[\u2713] HTML Exported")); // in case of an absolute path for DIST we must tell node to load the modules from our project root

            if (!paths.DIST.startsWith(paths.ROOT)) {
              process.env.NODE_PATH = paths.NODE_MODULES;

              require('module').Module._initPaths();
            } // Single threaded export


            if (!(maxThreads <= 1)) {
              _context2.next = 9;
              break;
            }

            console.log('Exporting HTML...');
            _context2.next = 7;
            return require('./exportRoutes.sync').default(state);

          case 7:
            _context2.next = 18;
            break;

          case 9:
            // Multi-threaded export
            threads = Math.min(cores, maxThreads);
            htmlProgress = (0, _utils.progress)(routes.length);
            console.log("Exporting HTML across ".concat(threads, " threads..."));
            exporters = [];

            for (i = 0; i < threads; i++) {
              exporters.push((0, _child_process.fork)(require.resolve('./exportRoutes.threaded'), [], {
                env: (0, _objectSpread2.default)({}, process.env, {
                  REACT_STATIC_THREAD: 'true'
                }),
                stdio: 'inherit'
              }));
            }

            exporterRoutes = exporters.map(function () {
              return [];
            });
            routes.forEach(function (route, i) {
              exporterRoutes[i % exporterRoutes.length].push(route);
            });
            _context2.next = 18;
            return Promise.all(exporters.map(function (exporter, i) {
              var routes = exporterRoutes[i];
              return new Promise(function (resolve, reject) {
                exporter.send((0, _objectSpread2.default)({}, state, {
                  routes: routes
                }));
                exporter.on('message', function (_ref) {
                  var type = _ref.type,
                      payload = _ref.payload;

                  if (type === 'error') {
                    reject(payload);
                  }

                  if (type === 'log') {
                    var _console;

                    (_console = console).log.apply(_console, (0, _toConsumableArray2.default)(payload));
                  }

                  if (type === 'tick') {
                    htmlProgress.tick();
                  }

                  if (type === 'done') {
                    resolve();
                  }
                });
              });
            }));

          case 18:
            (0, _utils.timeEnd)(_chalk.default.green("[\u2713] HTML Exported"));
            return _context2.abrupt("return", state);

          case 20:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _buildHTML.apply(this, arguments);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9zdGF0aWMvZXhwb3J0Um91dGVzLmpzIl0sIm5hbWVzIjpbImNvcmVzIiwiTWF0aCIsIm1heCIsIk9TIiwiY3B1cyIsImxlbmd0aCIsInN0YXRlIiwiYnVpbGRIVE1MIiwicGx1Z2lucyIsImFmdGVyRXhwb3J0IiwiZXhwb3J0Um91dGVzIiwicm91dGVzIiwiY29uZmlnIiwicGF0aHMiLCJtYXhUaHJlYWRzIiwiY2hhbGsiLCJncmVlbiIsIkRJU1QiLCJzdGFydHNXaXRoIiwiUk9PVCIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX1BBVEgiLCJOT0RFX01PRFVMRVMiLCJyZXF1aXJlIiwiTW9kdWxlIiwiX2luaXRQYXRocyIsImNvbnNvbGUiLCJsb2ciLCJkZWZhdWx0IiwidGhyZWFkcyIsIm1pbiIsImh0bWxQcm9ncmVzcyIsImV4cG9ydGVycyIsImkiLCJwdXNoIiwicmVzb2x2ZSIsIlJFQUNUX1NUQVRJQ19USFJFQUQiLCJzdGRpbyIsImV4cG9ydGVyUm91dGVzIiwibWFwIiwiZm9yRWFjaCIsInJvdXRlIiwiUHJvbWlzZSIsImFsbCIsImV4cG9ydGVyIiwicmVqZWN0Iiwic2VuZCIsIm9uIiwidHlwZSIsInBheWxvYWQiLCJ0aWNrIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOztBQUNBOztBQUNBOztBQUVBOztBQUNBOztBQUNBOztBQUNBOztBQUVBLElBQU1BLEtBQUssR0FBR0MsSUFBSSxDQUFDQyxHQUFMLENBQVNDLFlBQUdDLElBQUgsR0FBVUMsTUFBbkIsRUFBMkIsQ0FBM0IsQ0FBZDs7Ozs7Ozs0QkFFZ0IsaUJBQTRCQyxLQUE1QjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxtQkFDQSw0QkFBY0EsS0FBZCxDQURBOztBQUFBO0FBQ2RBLFlBQUFBLEtBRGM7QUFBQTtBQUFBLG1CQUVBLDBCQUFZQSxLQUFaLENBRkE7O0FBQUE7QUFFZEEsWUFBQUEsS0FGYztBQUFBO0FBQUEsbUJBR0FDLFNBQVMsQ0FB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SyxrQkFBQUEsTUFBTSxFQUFOQTtBQUZGO0FBSUFrQyxnQkFBQUEsUUFBUSxDQUFDRyxFQUFULENBQVksU0FBWixFQUF1QixnQkFBdUI7QUFBQSxzQkFBcEJDLElBQW9CLFFBQXBCQSxJQUFvQjtBQUFBLHNCQUFkQyxPQUFjLFFBQWRBLE9BQWM7O0FBQzVDLHNCQUFJRCxJQUFJLEtBQUssT0FBYixFQUFzQjtBQUNwQkgsb0JBQUFBLE1BQU0sQ0FBQ0ksT0FBRCxDQUFOO0FBQ0Q7O0FBQ0Qsc0JBQUlELElBQUksS0FBSyxLQUFiLEVBQW9CO0FBQUE7O0FBQ2xCLGdDQUFBdEIsT0FBTyxFQUFDQyxHQUFSLGtEQUFlc0IsT0FBZjtBQUNEOztBQUNELHNCQUFJRCxJQUFJLEtBQUssTUFBYixFQUFxQjtBQUNuQmpCLG9CQUFBQSxZQUFZLENBQUNtQixJQUFiO0FBQ0Q7O0FBQ0Qsc0JBQUlGLElBQUksS0FBSyxNQUFiLEVBQXFCO0FBQ25CYixvQkFBQUEsT0FBTztBQUNSO0FBQ0YsaUJBYkQ7QUFjRCxlQW5CTSxDQUFQO0FBb0JELGFBdEJELENBREksQ0E1Q1Y7O0FBQUE7QUF1RUUsZ0NBQVFyQixlQUFNQyxLQUFOLENBQVksd0JBQVosQ0FBUjtBQXZFRiw4Q0F5RVNWLEtBekVUOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEciLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgT1MgZnJvbSAnb3MnXG5pbXBvcnQgeyBmb3JrIH0gZnJvbSAnY2hpbGRfcHJvY2VzcydcbmltcG9ydCBjaGFsayBmcm9tICdjaGFsaydcblxuaW1wb3J0IHsgcHJvZ3Jlc3MsIHRpbWUsIHRpbWVFbmQgfSBmcm9tICcuLi91dGlscydcbmltcG9ydCBmZXRjaFNpdGVEYXRhIGZyb20gJy4vZmV0Y2hTaXRlRGF0YSdcbmltcG9ydCBmZXRjaFJvdXRlcyBmcm9tICcuL2ZldGNoUm91dGVzJ1xuaW1wb3J0IHBsdWdpbnMgZnJvbSAnLi9wbHVnaW5zJ1xuXG5jb25zdCBjb3JlcyA9IE1hdGgubWF4KE9TLmNwdXMoKS5sZW5ndGgsIDEpXG5cbmV4cG9ydCBkZWZhdWx0IChhc3luYyBmdW5jdGlvbiBleHBvcnRSb3V0ZXMoc3RhdGUpIHtcbiAgc3RhdGUgPSBhd2FpdCBmZXRjaFNpdGVEYXRhKHN0YXRlKVxuICBzdGF0ZSA9IGF3YWl0IGZldGNoUm91dGVzKHN0YXRlKVxuICBzdGF0ZSA9IGF3YWl0IGJ1aWxkSFRNTChzdGF0ZSlcbiAgc3RhdGUgPSBhd2FpdCBwbHVnaW5zLmFmdGVyRXhwb3J0KHN0YXRlKVxuICByZXR1cm4gc3RhdGVcbn0pXG5cbmFzeW5jIGZ1bmN0aW9uIGJ1aWxkSFRNTChzdGF0ZSkge1xuICBjb25zdCB7XG4gICAgcm91dGVzLFxuICAgIGNvbmZpZzogeyBwYXRocywgbWF4VGhyZWFkcyB9LFxuICB9ID0gc3RhdGVcblxuICB0aW1lKGNoYWxrLmdyZWVuKCdbXFx1MjcxM10gSFRNTCBFeHBvcnRlZCcpKVxuXG4gIC8vIGluIGNhc2Ugb2YgYW4gYWJzb2x1dGUgcGF0aCBmb3IgRElTVCB3ZSBtdXN0IHRlbGwgbm9kZSB0byBsb2FkIHRoZSBtb2R1bGVzIGZyb20gb3VyIHByb2plY3Qgcm9vdFxuICBpZiAoIXBhdGhzLkRJU1Quc3RhcnRzV2l0aChwYXRocy5ST09UKSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfUEFUSCA9IHBhdGhzLk5PREVfTU9EVUxFU1xuICAgIHJlcXVpcmUoJ21vZHVsZScpLk1vZHVsZS5faW5pdFBhdGhzKClcbiAgfVxuXG4gIC8vIFNpbmdsZSB0aHJlYWRlZCBleHBvcnRcbiAgaWYgKG1heFRocmVhZHMgPD0gMSkge1xuICAgIGNvbnNvbGUubG9nKCdFeHBvcnRpbmcgSFRNTC4uLicpXG4gICAgYXdhaXQgcmVxdWlyZSgnLi9leHBvcnRSb3V0ZXMuc3luYycpLmRlZmF1bHQoc3RhdGUpXG4gIH0gZWxzZSB7XG4gICAgLy8gTXVsdGktdGhyZWFkZWQgZXhwb3J0XG4gICAgY29uc3QgdGhyZWFkcyA9IE1hdGgubWluKGNvcmVzLCBtYXhUaHJlYWRzKVxuICAgIGNvbnN0IGh0bWxQcm9ncmVzcyA9IHByb2dyZXNzKHJvdXRlcy5sZW5ndGgpXG5cbiAgICBjb25zb2xlLmxvZyhgRXhwb3J0aW5nIEhUTUwgYWNyb3NzICR7dGhyZWFkc30gdGhyZWFkcy4uLmApXG5cbiAgICBjb25zdCBleHBvcnRlcnMgPSBbXVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhyZWFkczsgaSsrKSB7XG4gICAgICBleHBvcnRlcnMucHVzaChcbiAgICAgICAgZm9yayhyZXF1aXJlLnJlc29sdmUoJy4vZXhwb3J0Um91dGVzLnRocmVhZGVkJyksIFtdLCB7XG4gICAgICAgICAgZW52OiB7XG4gICAgICAgICAgICAuLi5wcm9jZXNzLmVudixcbiAgICAgICAgICAgIFJFQUNUX1NUQVRJQ19USFJFQUQ6ICd0cnVlJyxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHN0ZGlvOiAnaW5oZXJpdCcsXG4gICAgICAgIH0pXG4gICAgICApXG4gICAgfVxuXG4gICAgY29uc3QgZXhwb3J0ZXJSb3V0ZXMgPSBleHBvcnRlcnMubWFwKCgpID0+IFtdKVxuXG4gICAgcm91dGVzLmZvckVhY2goKHJvdXRlLCBpKSA9PiB7XG4gICAgICBleHBvcnRlclJvdXRlc1tpICUgZXhwb3J0ZXJSb3V0ZXMubGVuZ3RoXS5wdXNoKHJvdXRlKVxuICAgIH0pXG5cbiAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgIGV4cG9ydGVycy5tYXAoKGV4cG9ydGVyLCBpKSA9PiB7XG4gICAgICAgIGNvbnN0IHJvdXRlcyA9IGV4cG9ydGVyUm91dGVzW2ldXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgZXhwb3J0ZXIuc2VuZCh7XG4gICAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICAgIHJvdXRlcyxcbiAgICAgICAgICB9KVxuICAgICAgICAgIGV4cG9ydGVyLm9uKCdtZXNzYWdlJywgKHsgdHlwZSwgcGF5bG9hZCB9KSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xuICAgICAgICAgICAgICByZWplY3QocGF5bG9hZClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlID09PSAnbG9nJykge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyguLi5wYXlsb2FkKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICd0aWNrJykge1xuICAgICAgICAgICAgICBodG1sUHJvZ3Jlc3MudGljaygpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ2RvbmUnKSB7XG4gICAgICAgICAgICAgIHJlc29sdmUoKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIClcbiAgfVxuXG4gIHRpbWVFbmQoY2hhbGsuZ3JlZW4oJ1tcXHUyNzEzXSBIVE1MIEV4cG9ydGVkJykpXG5cbiAgcmV0dXJuIHN0YXRlXG59XG4iXX0=