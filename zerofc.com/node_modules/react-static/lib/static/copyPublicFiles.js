"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = copyPublicFolder;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _fsExtra = _interopRequireDefault(require("fs-extra"));

var _chalk = _interopRequireDefault(require("chalk"));

var _utils = require("../utils");

//
function copyPublicFolder(_x) {
  return _copyPublicFolder.apply(this, arguments);
}

function _copyPublicFolder() {
  _copyPublicFolder = (0, _asyncToGenerator2.default)(
  /*#__PURE__*/
  _regenerator.default.mark(function _callee(state) {
    var _state$config$paths, PUBLIC, DIST, INDEX;

    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _state$config$paths = state.config.paths, PUBLIC = _state$config$paths.PUBLIC, DIST = _state$config$paths.DIST, INDEX = _state$config$paths.INDEX;
            console.log('Copying public directory...');
            (0, _utils.time)(_chalk.default.green("[\u2713] Public directory copied"));
            _context.next = 5;
            return _fsExtra.default.ensureDir(PUBLIC);

          case 5:
            _context.next = 7;
            return _fsExtra.default.copy(PUBLIC, DIST, {
              dereference: true,
              filter: function filter(file) {
                return file !== INDEX;
              }
            });

          case 7:
            (0, _utils.timeEnd)(_chalk.default.green("[\u2713] Public directory copied"));
            return _context.abrupt("return", state);

          case 9:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _copyPublicFolder.apply(this, arguments);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9zdGF0aWMvY29weVB1YmxpY0ZpbGVzLmpzIl0sIm5hbWVzIjpbImNvcHlQdWJsaWNGb2xkZXIiLCJzdGF0ZSIsImNvbmZpZyIsInBhdGhzIiwiUFVCTElDIiwiRElTVCIsIklOREVYIiwiY29uc29sZSIsImxvZyIsImNoYWxrIiwiZ3JlZW4iLCJmcyIsImVuc3VyZURpciIsImNvcHkiLCJkZXJlZmVyZW5jZSIsImZpbHRlciIsImZpbGUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFFQTs7QUFEQTtTQUc4QkEsZ0I7Ozs7Ozs7NEJBQWYsaUJBQWdDQyxLQUFoQztBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsa0NBS1RBLEtBTFMsQ0FFWEMsTUFGVyxDQUdUQyxLQUhTLEVBR0FDLE1BSEEsdUJBR0FBLE1BSEEsRUFHUUMsSUFIUix1QkFHUUEsSUFIUixFQUdjQyxLQUhkLHVCQUdjQSxLQUhkO0FBT2JDLFlBQUFBLE9BQU8sQ0FBQ0MsR0FBUixDQUFZLDZCQUFaO0FBQ0EsNkJBQUtDLGVBQU1DLEtBQU4sQ0FBWSxrQ0FBWixDQUFMO0FBUmE7QUFBQSxtQkFVUEMsaUJBQUdDLFNBQUgsQ0FBYVIsTUFBYixDQVZPOztBQUFBO0FBQUE7QUFBQSxtQkFZUE8saUJBQUdFLElBQUgsQ0FBUVQsTUFBUixFQUFnQkMsSUFBaEIsRUFBc0I7QUFDMUJTLGNBQUFBLFdBQVcsRUFBRSxJQURhO0FBRTFCQyxjQUFBQSxNQUFNLEVBQUUsZ0JBQUFDLElBQUk7QUFBQSx1QkFBSUEsSUFBSSxLQUFLVixLQUFiO0FBQUE7QUFGYyxhQUF0QixDQVpPOztBQUFBO0FBaUJiLGdDQUFRRyxlQUFNQyxLQUFOLENBQVksa0NBQVosQ0FBUjtBQWpCYSw2Q0FtQk5ULEtBbkJNOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEciLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZnMgZnJvbSAnZnMtZXh0cmEnXG5pbXBvcnQgY2hhbGsgZnJvbSAnY2hhbGsnXG4vL1xuaW1wb3J0IHsgdGltZSwgdGltZUVuZCB9IGZyb20gJy4uL3V0aWxzJ1xuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBjb3B5UHVibGljRm9sZGVyKHN0YXRlKSB7XG4gIGNvbnN0IHtcbiAgICBjb25maWc6IHtcbiAgICAgIHBhdGhzOiB7IFBVQkxJQywgRElTVCwgSU5ERVggfSxcbiAgICB9LFxuICB9ID0gc3RhdGVcblxuICBjb25zb2xlLmxvZygnQ29weWluZyBwdWJsaWMgZGlyZWN0b3J5Li4uJylcbiAgdGltZShjaGFsay5ncmVlbignW1xcdTI3MTNdIFB1YmxpYyBkaXJlY3RvcnkgY29waWVkJykpXG5cbiAgYXdhaXQgZnMuZW5zdXJlRGlyKFBVQkxJQylcblxuICBhd2FpdCBmcy5jb3B5KFBVQkxJQywgRElTVCwge1xuICAgIGRlcmVmZXJlbmNlOiB0cnVlLFxuICAgIGZpbHRlcjogZmlsZSA9PiBmaWxlICE9PSBJTkRFWCxcbiAgfSlcblxuICB0aW1lRW5kKGNoYWxrLmdyZWVuKCdbXFx1MjcxM10gUHVibGljIGRpcmVjdG9yeSBjb3BpZWQnKSlcblxuICByZXR1cm4gc3RhdGVcbn1cbiJdfQ==