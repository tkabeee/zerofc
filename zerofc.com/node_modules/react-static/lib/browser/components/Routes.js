"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Routes = void 0;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _react = _interopRequireWildcard(require("react"));

var _2 = require("../");

var _useStaticInfo = require("../hooks/useStaticInfo");

var _useRoutePath = require("../hooks/useRoutePath");

//
var RoutesInner = function RoutesInner(_ref) {
  var routePath = _ref.routePath;
  // Let the user specify a manual routePath.
  // This is useful for animations where multiple routes
  // might be rendered simultaneously
  var staticInfo = (0, _useStaticInfo.useStaticInfo)(); // eslint-disable-next-line

  var _useState = (0, _react.useState)(0),
      _useState2 = (0, _slicedToArray2.default)(_useState, 2),
      _ = _useState2[0],
      setCount = _useState2[1]; // If in production, make sure the staticInfo is ingested into the
  // cache


  (0, _react.useState)(function () {
    // useState's initializer will only fire once per component instance,
    // and it will fire during the first render (unlike an effect, which
    // only fires after the first render). Think of it like a constructor call.
    if (process.env.REACT_STATIC_ENV === 'production' && staticInfo) {
      var path = staticInfo.path,
          sharedData = staticInfo.sharedData,
          sharedHashesByProp = staticInfo.sharedHashesByProp,
          template = staticInfo.template; // Hydrate routeInfoByPath with the embedded routeInfo

      _2.routeInfoByPath[path] = staticInfo; // Hydrate sharedDataByHash with the embedded routeInfo

      Object.keys(sharedHashesByProp).forEach(function (propKey) {
        _2.sharedDataByHash[sharedHashesByProp[propKey]] = sharedData[propKey];
      }); // In SRR and production, synchronously register the template for the
      // initial path

      (0, _2.registerTemplateForPath)(path, template);
    }
  });
  (0, _react.useEffect)(function () {
    return (0, _2.onReloadTemplates)(function () {
      setCount(function (old) {
        return old + 1;
      });
    });
  }); // If SSR, force the routePath to be the statically exported one

  if (typeof document === 'undefined') {
    routePath = staticInfo.path;
  } else if (!routePath) {
    // If a routePath is still not defined in the browser,
    // use the window location as the defualt
    routePath = decodeURIComponent(window.location.href);
  }

  routePath = (0, _useRoutePath.useRoutePath)(routePath); // Try and get the template

  var Comp = _2.templatesByPath[routePath]; // Detect a 404

  var is404 = routePath === '404'; // Detect a failed template

  if (_2.templateErrorByPath[routePath]) {
    is404 = true;
    Comp = _2.templatesByPath['404'];
  }

  if (!Comp) {
    if (is404) {
      throw new Error('Neither the page template or 404 template could be found. This means something is terribly wrong. Please, file an issue!');
    } // Suspend while we fetch the resource


    throw Promise.all([new Promise(function (resolve) {
      return setTimeout(resolve, 500);
    }), (0, _2.prefetch)(routePath, {
      priority: true
    })]);
  }

  return _react.default.createElement(_useRoutePath.routePathContext.Provider, {
    value: routePath
  }, _react.default.createElement(Comp, {
    is404: is404
  }));
};

var Routes = function Routes(_ref2) {
  var routePath = _ref2.routePath;
  // Once a routePath goes into the Routes component,
  // useRoutePath must ALWAYS return the routePath used
  // in its parent, so we pass it down as context
  // Get the Routes hook
  var CompWrapper = (0, _react.useMemo)(function () {
    return _2.plugins.Routes(function (props) {
      return _react.default.createElement(RoutesInner, props);
    });
  }, [_2.plugins]);
  return _react.default.createElement(CompWrapper, {
    routePath: routePath
  });
};

exports.Routes = Routes;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9icm93c2VyL2NvbXBvbmVudHMvUm91dGVzLmpzIl0sIm5hbWVzIjpbIlJvdXRlc0lubmVyIiwicm91dGVQYXRoIiwic3RhdGljSW5mbyIsIl8iLCJzZXRDb3VudCIsInByb2Nlc3MiLCJlbnYiLCJSRUFDVF9TVEFUSUNfRU5WIiwicGF0aCIsInNoYXJlZERhdGEiLCJzaGFyZWRIYXNoZXNCeVByb3AiLCJ0ZW1wbGF0ZSIsInJvdXRlSW5mb0J5UGF0aCIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwicHJvcEtleSIsInNoYXJlZERhdGFCeUhhc2giLCJvbGQiLCJkb2N1bWVudCIsImRlY29kZVVSSUNvbXBvbmVudCIsIndpbmRvdyIsImxvY2F0aW9uIiwiaHJlZiIsIkNvbXAiLCJ0ZW1wbGF0ZXNCeVBhdGgiLCJpczQwNCIsInRlbXBsYXRlRXJyb3JCeVBhdGgiLCJFcnJvciIsIlByb21pc2UiLCJhbGwiLCJyZXNvbHZlIiwic2V0VGltZW91dCIsInByaW9yaXR5IiwiUm91dGVzIiwiQ29tcFdyYXBwZXIiLCJwbHVnaW5zIiwicHJvcHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTs7QUFFQTs7QUFVQTs7QUFDQTs7QUFaQTtBQWNBLElBQU1BLFdBQVcsR0FBRyxTQUFkQSxXQUFjLE9BQW1CO0FBQUEsTUFBaEJDLFNBQWdCLFFBQWhCQSxTQUFnQjtBQUNyQztBQUNBO0FBQ0E7QUFFQSxNQUFNQyxVQUFVLEdBQUcsbUNBQW5CLENBTHFDLENBTXJDOztBQU5xQyxrQkFPZixxQkFBUyxDQUFULENBUGU7QUFBQTtBQUFBLE1BTzlCQyxDQVA4QjtBQUFBLE1BTzNCQyxRQVAyQixrQkFTckM7QUFDQTs7O0FBQ0EsdUJBQVMsWUFBTTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFFBQUlDLE9BQU8sQ0FBQ0MsR0FBUixDQUFZQyxnQkFBWixLQUFpQyxZQUFqQyxJQUFpREwsVUFBckQsRUFBaUU7QUFBQSxVQUN2RE0sSUFEdUQsR0FDSk4s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Q0QsQ0FaTSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyB1c2VTdGF0ZSwgdXNlTWVtbywgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnXG4vL1xuaW1wb3J0IHtcbiAgdGVtcGxhdGVzQnlQYXRoLFxuICB0ZW1wbGF0ZUVycm9yQnlQYXRoLFxuICByb3V0ZUluZm9CeVBhdGgsXG4gIHNoYXJlZERhdGFCeUhhc2gsXG4gIHJlZ2lzdGVyVGVtcGxhdGVGb3JQYXRoLFxuICBwcmVmZXRjaCxcbiAgcGx1Z2lucyxcbiAgb25SZWxvYWRUZW1wbGF0ZXMsXG59IGZyb20gJy4uLydcbmltcG9ydCB7IHVzZVN0YXRpY0luZm8gfSBmcm9tICcuLi9ob29rcy91c2VTdGF0aWNJbmZvJ1xuaW1wb3J0IHsgcm91dGVQYXRoQ29udGV4dCwgdXNlUm91dGVQYXRoIH0gZnJvbSAnLi4vaG9va3MvdXNlUm91dGVQYXRoJ1xuXG5jb25zdCBSb3V0ZXNJbm5lciA9ICh7IHJvdXRlUGF0aCB9KSA9PiB7XG4gIC8vIExldCB0aGUgdXNlciBzcGVjaWZ5IGEgbWFudWFsIHJvdXRlUGF0aC5cbiAgLy8gVGhpcyBpcyB1c2VmdWwgZm9yIGFuaW1hdGlvbnMgd2hlcmUgbXVsdGlwbGUgcm91dGVzXG4gIC8vIG1pZ2h0IGJlIHJlbmRlcmVkIHNpbXVsdGFuZW91c2x5XG5cbiAgY29uc3Qgc3RhdGljSW5mbyA9IHVzZVN0YXRpY0luZm8oKVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgY29uc3QgW18sIHNldENvdW50XSA9IHVzZVN0YXRlKDApXG5cbiAgLy8gSWYgaW4gcHJvZHVjdGlvbiwgbWFrZSBzdXJlIHRoZSBzdGF0aWNJbmZvIGlzIGluZ2VzdGVkIGludG8gdGhlXG4gIC8vIGNhY2hlXG4gIHVzZVN0YXRlKCgpID0+IHtcbiAgICAvLyB1c2VTdGF0ZSdzIGluaXRpYWxpemVyIHdpbGwgb25seSBmaXJlIG9uY2UgcGVyIGNvbXBvbmVudCBpbnN0YW5jZSxcbiAgICAvLyBhbmQgaXQgd2lsbCBmaXJlIGR1cmluZyB0aGUgZmlyc3QgcmVuZGVyICh1bmxpa2UgYW4gZWZmZWN0LCB3aGljaFxuICAgIC8vIG9ubHkgZmlyZXMgYWZ0ZXIgdGhlIGZpcnN0IHJlbmRlcikuIFRoaW5rIG9mIGl0IGxpa2UgYSBjb25zdHJ1Y3RvciBjYWxsLlxuICAgIGlmIChwcm9jZXNzLmVudi5SRUFDVF9TVEFUSUNfRU5WID09PSAncHJvZHVjdGlvbicgJiYgc3RhdGljSW5mbykge1xuICAgICAgY29uc3QgeyBwYXRoLCBzaGFyZWREYXRhLCBzaGFyZWRIYXNoZXNCeVByb3AsIHRlbXBsYXRlIH0gPSBzdGF0aWNJbmZvXG5cbiAgICAgIC8vIEh5ZHJhdGUgcm91dGVJbmZvQnlQYXRoIHdpdGggdGhlIGVtYmVkZGVkIHJvdXRlSW5mb1xuICAgICAgcm91dGVJbmZvQnlQYXRoW3BhdGhdID0gc3RhdGljSW5mb1xuXG4gICAgICAvLyBIeWRyYXRlIHNoYXJlZERhdGFCeUhhc2ggd2l0aCB0aGUgZW1iZWRkZWQgcm91dGVJbmZvXG4gICAgICBPYmplY3Qua2V5cyhzaGFyZWRIYXNoZXNCeVByb3ApLmZvckVhY2gocHJvcEtleSA9PiB7XG4gICAgICAgIHNoYXJlZERhdGFCeUhhc2hbc2hhcmVkSGFzaGVzQnlQcm9wW3Byb3BLZXldXSA9IHNoYXJlZERhdGFbcHJvcEtleV1cbiAgICAgIH0pXG5cbiAgICAgIC8vIEluIFNSUiBhbmQgcHJvZHVjdGlvbiwgc3luY2hyb25vdXNseSByZWdpc3RlciB0aGUgdGVtcGxhdGUgZm9yIHRoZVxuICAgICAgLy8gaW5pdGlhbCBwYXRoXG4gICAgICByZWdpc3RlclRlbXBsYXRlRm9yUGF0aChwYXRoLCB0ZW1wbGF0ZSlcbiAgICB9XG4gIH0pXG5cbiAgdXNlRWZmZWN0KCgpID0+XG4gICAgb25SZWxvYWRUZW1wbGF0ZXMoKCkgPT4ge1xuICAgICAgc2V0Q291bnQob2xkID0+IG9sZCArIDEpXG4gICAgfSlcbiAgKVxuXG4gIC8vIElmIFNTUiwgZm9yY2UgdGhlIHJvdXRlUGF0aCB0byBiZSB0aGUgc3RhdGljYWxseSBleHBvcnRlZCBvbmVcbiAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByb3V0ZVBhdGggPSBzdGF0aWNJbmZvLnBhdGhcbiAgfSBlbHNlIGlmICghcm91dGVQYXRoKSB7XG4gICAgLy8gSWYgYSByb3V0ZVBhdGggaXMgc3RpbGwgbm90IGRlZmluZWQgaW4gdGhlIGJyb3dzZXIsXG4gICAgLy8gdXNlIHRoZSB3aW5kb3cgbG9jYXRpb24gYXMgdGhlIGRlZnVhbHRcbiAgICByb3V0ZVBhdGggPSBkZWNvZGVVUklDb21wb25lbnQod2luZG93LmxvY2F0aW9uLmhyZWYpXG4gIH1cblxuICByb3V0ZVBhdGggPSB1c2VSb3V0ZVBhdGgocm91dGVQYXRoKVxuXG4gIC8vIFRyeSBhbmQgZ2V0IHRoZSB0ZW1wbGF0ZVxuICBsZXQgQ29tcCA9IHRlbXBsYXRlc0J5UGF0aFtyb3V0ZVBhdGhdXG5cbiAgLy8gRGV0ZWN0IGEgNDA0XG4gIGxldCBpczQwNCA9IHJvdXRlUGF0aCA9PT0gJzQwNCdcblxuICAvLyBEZXRlY3QgYSBmYWlsZWQgdGVtcGxhdGVcbiAgaWYgKHRlbXBsYXRlRXJyb3JCeVBhdGhbcm91dGVQYXRoXSkge1xuICAgIGlzNDA0ID0gdHJ1ZVxuICAgIENvbXAgPSB0ZW1wbGF0ZXNCeVBhdGhbJzQwNCddXG4gIH1cblxuICBpZiAoIUNvbXApIHtcbiAgICBpZiAoaXM0MDQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ05laXRoZXIgdGhlIHBhZ2UgdGVtcGxhdGUgb3IgNDA0IHRlbXBsYXRlIGNvdWxkIGJlIGZvdW5kLiBUaGlzIG1lYW5zIHNvbWV0aGluZyBpcyB0ZXJyaWJseSB3cm9uZy4gUGxlYXNlLCBmaWxlIGFuIGlzc3VlISdcbiAgICAgIClcbiAgICB9XG4gICAgLy8gU3VzcGVuZCB3aGlsZSB3ZSBmZXRjaCB0aGUgcmVzb3VyY2VcbiAgICB0aHJvdyBQcm9taXNlLmFsbChbXG4gICAgICBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNTAwKSksXG4gICAgICBwcmVmZXRjaChyb3V0ZVBhdGgsIHsgcHJpb3JpdHk6IHRydWUgfSksXG4gICAgXSlcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgPHJvdXRlUGF0aENvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3JvdXRlUGF0aH0+XG4gICAgICA8Q29tcCBpczQwND17aXM0MDR9IC8+XG4gICAgPC9yb3V0ZVBhdGhDb250ZXh0LlByb3ZpZGVyPlxuICApXG59XG5cbmV4cG9ydCBjb25zdCBSb3V0ZXMgPSAoeyByb3V0ZVBhdGggfSkgPT4ge1xuICAvLyBPbmNlIGEgcm91dGVQYXRoIGdvZXMgaW50byB0aGUgUm91dGVzIGNvbXBvbmVudCxcbiAgLy8gdXNlUm91dGVQYXRoIG11c3QgQUxXQVlTIHJldHVybiB0aGUgcm91dGVQYXRoIHVzZWRcbiAgLy8gaW4gaXRzIHBhcmVudCwgc28gd2UgcGFzcyBpdCBkb3duIGFzIGNvbnRleHRcblxuICAvLyBHZXQgdGhlIFJvdXRlcyBob29rXG4gIGNvbnN0IENvbXBXcmFwcGVyID0gdXNlTWVtbyhcbiAgICAoKSA9PiBwbHVnaW5zLlJvdXRlcyhwcm9wcyA9PiA8Um91dGVzSW5uZXIgey4uLnByb3BzfSAvPiksXG4gICAgW3BsdWdpbnNdXG4gIClcblxuICByZXR1cm4gPENvbXBXcmFwcGVyIHJvdXRlUGF0aD17cm91dGVQYXRofSAvPlxufVxuIl19